\documentclass[a4paper,11pt]{article}
\input{config.tex}

\title{\huge \bfseries Introduction to Kotlin}
\author{
  Christian Konersmann, Finn Paul Lippok, Paul Lukas\\[1ex]
  RWTH Aachen University, Aachen, Germany\\
  \texttt{\{christian.konersmann,finn.lippok,paul.lukas\}@rwth-aachen.de}\\
  \and
  Proseminar: Advanced Programming Concepts\\
  Organiser: Prof.\ Dr.\ Jürgen Giesl\\
  Supervisor: Jan-Christoph Kassing
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This paper introduces Kotlin, a statically typed, object-oriented programming language designed to be fully interoperable with Java and the Java Virtual Machine (JVM). It focuses on Kotlin's concise syntax, advanced features such as null safety, and extensive platform support enabled by its multiplatform development capability. These features make Kotlin a modern and powerful programming language.
\end{abstract}

\section{Introduction}
Kotlin is a modern programming language developed by JetBrains, a renowned software development company. Designed as a safer and more concise alternative to Java, Kotlin offers full interoperability with Java, allowing developers to leverage existing Java libraries and frameworks while benefiting from Kotlin's modern features. Its clean and expressive syntax has made it increasingly popular, particularly in Android development. In fact, Google announced Kotlin as its preferred language for Android app development in 2019~\cite{intro-google}. Beyond Android, Kotlin supports multiplatform development, enabling developers to build applications for the server, desktop, web, and iOS from a shared codebase~\cite{intro-multiplatform-dev}.

This paper presents an overview of Kotlin’s concise syntax and highlights key language features that illustrate its advantages over Java. It assumes a basic understanding of Java and begins by examining core syntactic differences between Kotlin and Java, followed by an introduction to concepts such as null safety and seamless Java interoperability. The paper concludes with a discussion of Kotlin’s multiplatform capabilities, with particular emphasis on its application in Android development.

\section{Basic Syntax}
This section covers the basic syntax of Kotlin and highlights its differences compared to Java. The goal is to provide a concise overview focused on the most important distinctions.

\subsection{Program Entry Point and Method Declaration}
The \textit{main} method is the entry point of any Java or Kotlin program~\cite{program-entry-point}. Java enforces object-oriented programming, thus requiring the \textit{main} method to be declared within a class. For the \textit{main} method to be directly executable, it must be \textit{public} and \textit{static},\footnote{If the \textit{main} method were non-static, it would require an instance of the class before it could be run, leading to a circular dependency.} as shown below:

\begin{lstlisting}[language=Java, title={Java main method}]
public class Main {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
}
\end{lstlisting}

Kotlin, on the other hand, does not require methods to be declared inside a class, allowing for a more functional programming style with top-level functions. These top-level functions can be called directly without the need to instantiate a class~\cite{kotlin-functions-scope}, functioning similarly to static methods in Java,\footnote{When compiling Kotlin to Java bytecode, top-level functions are compiled as static methods in a class named after the file.} but without an explicit class affiliation. Kotlin further reduces boilerplate by having \textit{public} as the default visibility~\cite{visibility-modifiers} and allowing the \textit{main} method to omit arguments passed as an array~\cite{program-entry-point}. Also, semicolons are optional, and Kotlin introduces the \textit{fun} keyword for defining functions~\cite{functions}, resulting in a concise and readable syntax, as shown here:

\begin{lstlisting}[language=Kotlin, title={Kotlin main method}]
fun main() {
  println("Hello, World!")
}
\end{lstlisting}

\subsection{Variable Declaration}
Variables in Kotlin are declared using the keyword \textit{val} for immutable variables or \textit{var} for mutable variables~\cite{variables}, similar to Java's \textit{final} and non-final variables. The type is declared after the variable name, separated by a colon:

\begin{lstlisting}[language=Java, title={Java data types}]
final String name = "John Doe";
int age = 42;
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin data types}]
val name: String = "John Doe"
var age: Int = 42
\end{lstlisting}

\subsection{Type Inference}
Kotlin supports type inference, allowing the compiler to infer a variable's type based on its initializer or usage~\cite{type-inference}. However, a detailed discussion of its internal workings is out of scope for this paper.

\begin{lstlisting}[language=Kotlin]
val name = "John Doe" // type is inferred as String
var age = 42 // type is inferred as Int
\end{lstlisting}

\subsection{Return Type Declaration}
Similar to variable declaration, a method's return type is declared after the method name and parameters, separated by a colon~\cite{functions}. The equivalent of \textit{void} in Java is \textit{Unit} in Kotlin~\cite{builtin-types-unit,kotlin-stdlib-unit}, which can be omitted if no value is returned.

\begin{lstlisting}[language=Java, title={Java method declaration}]
public int add(int a, int b) {
  return a + b;
}
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin method declaration}]
fun add(a: Int, b: Int): Int {
  return a + b
}
\end{lstlisting}

\subsection{Everything is an Object}
In Kotlin, there are no primitive types.\footnote{Certain types may be optimized to use Java primitives at runtime for performance reasons.} All types are objects and inherit from the \textit{Any} class~\cite{basic-types}. This approach creates a more consistent object-oriented programming model and eliminates the need for wrapper classes.

\begin{lstlisting}[language=Java, title={Java Integer Wrapper}]
Integer.valueOf(42).hashCode();
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin direct usage of Int}]
42.hashCode()
\end{lstlisting}

Furthermore, functions in Kotlin are also treated as objects~\cite{higher-order-functions}, enabling higher-order functions and functional programming paradigms. As a result, functions can be passed as arguments, returned from other functions, and assigned to variables.

\section{Classes}
In both Java and Kotlin, classes are declared using the \textit{class} keyword~\cite{classes} and can contain attributes, methods, and constructors. In the example below, we declare a class to represent a salesperson:

\begin{lstlisting}[language=Java, title={Java Class Declaration}]
public class SalesPerson {
  private final String name;
  private final int commissionRate;
  private double salesVolume;
  
  public SalesPerson(String name, int commissionRate, double transferAmount) {
    this.name = name;
    this.commissionRate = commissionRate;
    this.salesVolume = transferAmount;
  }
}
\end{lstlisting}

Kotlin improves upon Java by allowing the constructor to be declared directly within the class definition~\cite{classes-constructors}. As a reminder, the default visibility in Kotlin is \textit{public}, and classes are also \textit{final} by default, meaning they cannot be inherited from unless explicitly declared \textit{open}. Kotlin also permits the declaration of constructor parameters (as properties) using \textit{val} or \textit{var}, including visibility modifiers~\cite{classes-constructors}, resembling the concise syntax found in Java records:

\begin{lstlisting}[language=Kotlin,title={Kotlin Class Declaration}]
class SalesPerson(val name: String, private val commissionRate: Int, transferAmount: Double = 0.0) {
  var salesVolume: Double = transferAmount
}
\end{lstlisting}

In this example, \textit{name} and \textit{commissionRate} become properties of the class, while \textit{transferAmount} is a constructor parameter used to initialize \textit{salesVolume}. It is still possible to declare attributes outside the constructor. Additionally, Kotlin allows default parameter values in constructors and functions, a feature that would otherwise require method overloading in Java.

\subsection{Properties}
Properties in Kotlin facilitate concise declaration of getters and setters, including their visibility, directly beside the corresponding attribute~\cite{declaring-properties,properties-getters-setters}. Unlike Java, accessing a property in Kotlin via dot notation will internally call the corresponding getter or setter method, ensuring a consistent syntax.
If only the visibility needs to be restricted, the property can be declared as shown below:

\begin{lstlisting}[language=Kotlin, title={Private setter}]
var salesVolume: Double = transferAmount
  private set
\end{lstlisting}

For more complex logic, custom getters and setters can be defined inline~\cite{properties-getters-setters}. The \texttt{field} keyword refers to the underlying attribute:

\begin{lstlisting}[language=Kotlin, title={Custom accessors}]
var salesVolume: Double = transferAmount
  private set(value) {
    if (value < 0)
      throw IllegalArgumentException("SV must be positive")
    field = value
  }
\end{lstlisting}

Kotlin also supports computed properties, which do not store a value but compute it on access via a custom getter~\cite{properties-getters-setters}. This approach mirrors writing a getter method in Java without a backing field:

\begin{lstlisting}[language=Kotlin, title={Computed Property}]
val commission: Double
  get() = salesVolume * commissionRate
\end{lstlisting}

\section{String Interpolation}
In Java, variables are typically formatted into strings using the \textit{String.format()} method or by concatenation with the \texttt{+} operator. Kotlin introduces a more readable mechanism called string interpolation~\cite{string-concatenation}, allowing variables and expressions to be directly embedded within a string by prefixing them with a \texttt{\$} sign, and enclosing expressions in curly braces:

\begin{lstlisting}[language=Kotlin, title={String Interpolation}]
fun printSalesPerson() {
  println("Name: $name, Sales in USD: ${salesVolume * 1.2}")
}
\end{lstlisting}

\section{Null Safety}
Whenever a method or attribute is accessed on a null reference in Java, a \texttt{NullPointerException} (NPE) is thrown. Kotlin eliminates this risk with a null safety system that distinguishes between nullable and non-nullable types~\cite{nullsafety,nullsafety-nullable-types}. By default, all types in Kotlin are non-nullable, meaning variables cannot hold a null value unless explicitly declared with a question mark:
Kotlin enforces this distinction at compile time, requiring developers to handle nullable types explicitly. At runtime, both types are treated the same.
\begin{lstlisting}[language=Kotlin]
var a: String = "a is non-nullable"
var b: String? = "b is nullable"
\end{lstlisting}

\subsection{Null Safety Operators}
When working with nullable types, you cannot directly access properties or methods, because the reference could be \texttt{null}, potentially causing an NPE.
In Java, this is typically handled with an if check, as shown in the following example:
\begin{lstlisting}[language=Java]
  private final SalesPerson supervisor;

  public void printSupervisor() {
    if (supervisor == null) System.out.println("null");
    else System.out.println(supervisor.name);
  }
\end{lstlisting}

This approach is also available in Kotlin, where checking for a null value in an if statement automatically casts the type to a non-nullable type within the scope of the statement~\cite{nullsafety-if-condition}.\footnote{This feature is known as smart casting, where the compiler automatically casts the variable to a more specific type when it can guarantee the safety of the cast.}
However, Kotlin provides convenient shortcuts for handling nullable types by using Null safety operators.

\subsubsection{Safe Call Operator}
The safe call operator \texttt{?.}\ allows you to access properties or methods of an object only if it is non-null, thereby reducing the need for explicit null checks~\cite{nullsafety-safe-call}.
If the object is \texttt{null}, the expression safely evaluates to \texttt{null}, avoiding an NPE\@.
Otherwise, it evaluates as expected, granting access to the object's attributes or methods.
Essentially, this operator enhances the standard dot notation by incorporating null safety. 

\begin{lstlisting}[language=Kotlin]
val supervisor: SalesPerson? = null
fun printSupervisor() {
  println(supervisor?.name)
}
\end{lstlisting}

Multiple safe calls can be chained~\cite{nullsafety-safe-call}, and if any segment is \texttt{null}, the entire chain evaluates to \texttt{null}.
Furthermore, Safe calls can also be used on the left side of an assignment. If the safe call operator evaluates to null, the assignment will be skipped.

\begin{lstlisting}[language=Kotlin]
// Chained safe call operators
var volume: Double? = supervisor?.supervisor?.salesVolume
// Assignment with a chained operator
supervisor?.supervisor?.salesVolume = 0.0
\end{lstlisting}

\subsubsection{Elvis Operator}
The Elvis operator \texttt{?:} is an enhanced version of the safe call operator, offering a more concise way to handle \texttt{null} values. If the expression on the left side evaluates to \texttt{null}, it returns a default value specified to the right side of \texttt{?:}~\cite{nullsafety-elvis}:

\begin{lstlisting}[language=Kotlin]
fun printSupervisor() {
  println(supervisor?.name ?: "No supervisor")
}
\end{lstlisting}

When compiling to Java, both the safe call operator and the Elvis operator are treated by the compiler as if statements. These operators simply make the code significantly shorter and easier to read, therefore increasing the maintainability as well.

\subsubsection{Not-Null Assertion Operator}
The not-null assertion operator (\texttt{!!}) converts a nullable type to a non-nullable type, instructing the compiler to treat the value as non-null~\cite{nullsafety-assertion}. However, if the value is actually \texttt{null}, a \texttt{NullPointerException} will be thrown.
This operator contradicts the concept of null safety and should only be used when the programmer is certain that the value cannot be null, but the compiler is unable to guarantee it.

\begin{lstlisting}[language=Kotlin, title={Usage of the not-null assertion}]
var possiblyNull: String? = null
var b: String = possiblyNull!!
\end{lstlisting}

\subsection{Nullable Receiver}
  We have already covered extension functions in the chapter on Classes. As a brief reminder, extension functions are external additions to a class that introduce new methods, which can be called on an instance of the class using dot notation.

  Since extension functions are not actually part of the class itself but merely an extension that can be called using dot notation, it is possible for the object to be null while still being able to call the extension method \cite{nullsafety-nullable-receiver}. To achieve this, the function must have a so-called \textit{nullable receiver} type, which is indicated by a question mark after the class the extension function is defined for. As a result, the method remains accessible even if the object is null. This allows values of a nullable type to be accessed without checking for null beforehand, as the null case is handled within the method itself. The following example demonstrates how to define and properly use an extension function with a nullable receiver type.
  \begin{lstlisting}[language=Kotlin,title={Usage of an extension function}]
    // define the extension function
    fun SalesPeron?.print() {
        if (this == null) return println("This person dose not exist.")
        return println("$name: $salesVolume sold")
    }
    // use the extension function
    var sales: SalesPeron? = null
    sales.print() // This person dose not exist.
    sales = SalesPeron("Carl", 1200)
    sales.print() // Carl: 0.0 sold
  \end{lstlisting}

\section{Interoperability}
  This chapter focuses on interoperability between Java and Kotlin. In this context, interoperability refers to the seamless compatibility between the two languages. Kotlin was designed to integrate smoothly with Java code and vice versa, making it easy to use both within the same project.

\subsection{Call Java in Kotlin}
  Everything written in Java is accessible in Kotlin, but interoperability is especially useful when working with Java libraries. There are already countless libraries written in Java that can now be used in Kotlin, eliminating the need to rewrite a library with the same functionality specifically for Kotlin. This applies to both the official Java standard libraries and more specialized external libraries. Additionally, interoperability makes it much easier to migrate existing Java projects to Kotlin, as they do not need to be completely rewritten. This once again shows that Kotlin is a well-thought-out language designed to serve as an improvement over Java.

\subsubsection{Create and acces objects}
  Kotlin was specifically designed to support the use and execution of any Java code within a Kotlin project \cite{interop}. To illustrate how Java code can be accessed, the following example features a Salesman class that stores basic information using getters and setters.
  \begin{lstlisting}[language=Java,title={Example java class}]
public class Salesman {
  private final String name;
  private int salary;
  
      public Salesman(String name, String title, int salary) {
    this.name = name;
    this.salary = salary;
  }

  public String getName() { return name; }

  public int getSalary() { return salary; }

  public void setSalary(int salary) { this.salary = salary; }
}
\end{lstlisting}
  If we want to access this class from Kotlin and create an instance of it, we can use the familiar Kotlin syntax \cite{interop} to instantiate the object and access its properties. There is no syntactical difference between calling or creating a Java class and a Kotlin class. Since getter and setter methods are unnecessary in Kotlin, they are automatically converted if they follow Java conventions for getter and setter methods \cite{interop-getter-setter}. This allows them to be accessed using Kotlin's property syntax. The resulting attributes are called synthetic properties \cite{interop-synthetic-property}. If the getters and setters do not follow Java conventions, they can still be accessed as regular methods.
\begin{lstlisting}[language=Kotlin, title={Access the Salesman class in Kotlin}]
    var carl = Salesman("carl mueller", 4500)
    println(carl.name) // prints 'carl mueller'
    carl.salary = 4600 // sets salary to 4600
    carl.setSalary(4600) // alternivly to the above
  \end{lstlisting}
  Kotlin detects that the name field in the Java class is final and has a getter but no setter. As a result, the compiler throws an error if an attempt is made to modify its value, ensuring that the getters and setters behave the same way as in Kotlin. If the field had only a setter, the method would not be converted into a synthetic property, as Kotlin does not support set-only properties \cite{interop-synthetic-property}. % Zitat von Kotlin website, wortlaut sehr ähnlich

\subsubsection{Mapped types}
  By default, when objects of a Java class are used in Kotlin, they are loaded as Java objects. However, some Java types have a corresponding Kotlin counterpart, and the Java object is automatically replaced with the equivalent Kotlin type \cite{interop-mapped-types}. For example, 'java.lang.Integer' is converted to 'kotlin.Int?' because Java wrapper objects can be null. This applies to all Java wrapper classes and some important types, such as 'java.lang.Object', which is mapped to 'kotlin.Any!'\footnote{The exclamation mark indicates that this is a platform type. More on this in the next chapter.}. Collections like Lists, Maps and Arrays are also converted. Additionally, all Java primitive types are mapped to their non-nullable Kotlin counterparts, as primitive types cannot be null in Java. For instance, the Java 'int' is converted to 'kotlin.Int'. For a complete list of all mapped types, refer to the official documentation.

\subsubsection{Null safety with Java}
  Since Java does not distinguish between nullable and non-nullable types, any object returned from Java code can be null. This contradicts Kotlin's strict null safety concept and would make working with Java objects impractical.
  To address this, Kotlin introduces \textit{platform types} for objects created through Java code. If a Java type does not have a direct Kotlin equivalent, as is the case for most Java types, the compiler assigns it a platform type, which is non-denotable \cite{interop-null-safety}. This means we cannot explicitly declare or write this type as we do with nullable types using a question mark\footnote{When the compiler needs to report a type-related error, it uses an exclamation mark to indicate the platform type \cite{interop-platform-notation}.}. With platform types, Kotlin relaxes its strict null safety rules, making their handling similar to Java. However, this increases the risk of NullPointerExceptions.
  To see how we can use this in practice, we have extended the previously introduced Java Salesman class with the following method:
  \begin{lstlisting}[language=Java]
    public static List<Salesman> createList() {
      List<Salesman>  list = new ArrayList<>();
      list.add(null);
      list.add(new Salesman("Carl", 4200));
      return list;
    }
  \end{lstlisting}
  If we access this method through Kotlin, we get the List containing the two Elements created in Java. Since both Objects are created in Java and could be null, they are assigned the platform type, thus the developer can decide if the variable should be nullable or non-nullable.
  \begin{lstlisting}[language=Kotlin]  
    val list = Salesman.createList()
    println(list::class.qualifiedName)
    var item: Salesman = list[0]
    var nullableItem: Salesman? = list[1]
    println(item.name) // allowed but would throw NPE
  \end{lstlisting}
  If we set the type to non-nullable but the object is actually null, attempting to access its members will result in a NullPointerException, as shown above. Therefore, it is always safer to use nullable types.

  Some Java compilers use annotations \cite{interop-nullability-annotations} to specify whether a value is nullable or non-nullable, such as JetBrains' @Nullable or @NotNull annotation \cite{JetBrains-annotations}. If these annotations are present in the Java code, the compiler assigns the corresponding nullable or non-nullable Kotlin type to the variable instead of a platform type. If we had a method returning a simple String with a @NotNull annotation in our Salesman class, the variable would actually assigned the non-nullable type instead of the platform type:
  \begin{lstlisting}[language=Java]
    public static @NotNull String getString() {
      return "Not null";
    }
  \end{lstlisting}
  \begin{lstlisting}[language=Kotlin]
    val str: String = Salesman.getString() // non-nullable type
\end{lstlisting}

\subsubsection{Java arrays in Kotlin}
  In Java, arrays of primitive types can be used to achieve better performance, as they avoid the overhead associated with objects. Kotlin prohibits the direct use of primitive arrays but provides specialized classes for each primitive type instead \cite{interop-arrays}. The compiler optimizes the code and uses primitive arrays whenever possible. For example, Java's 'int[]' corresponds to Kotlin's 'IntArray'. These classes compile down to actual primitive arrays to minimize object overhead.

  Let's assume we have a function in Java that requires a primitive array:
\begin{lstlisting}[language=Java]
public static void takeArray(int[] array) { ... }
\end{lstlisting}
  To call this function from Kotlin without unnecessary boxing, we should use intArrayOf() instead of arrayOf(). This ensures that the array compiles down to Java's 'int[]', avoiding the overhead of boxed Integer objects. Even in for loops, the Kotlin compiler optimizes iteration over primitive arrays, ensuring that no iterator is created. This results in significant performance improvements compared to iterating over an Array<Int>, which would involve additional function calls and object overhead.
\begin{lstlisting}[language=Kotlin]
    var array: IntArray = intArrayOf(1, 2, 3)
    takeArray(array) // passes int[] to Java function
    for (i in array.indices) // no iterator created
        println(array[i]) // no calls to Array's get() or set()
\end{lstlisting}

  In Java, arrays are covariant, meaning an array of a subtype can be assigned to an array of its superclass. This is allowed at compile time, but Java enforces type safety at runtime. If an instance of a type that differs from the array's original type is assigned to it, an ArrayStoreException will be thrown. This happens because mixing different types in the array would break type safety. To counteract this problem, Kotlin simply dose not allow this, thus there arrays are invariant \cite{interop-arrays}. However there is an exception when you need to parse an array to Java, it is allowed for platform types, because Java treates arrays as covariant. If we had a method, that requires a Object array, we could parse a string array of platform type to it.
  \begin{lstlisting}[language=Java]
    public static void takeArray(Object[] array) { ... }
  \end{lstlisting}
  \begin{lstlisting}[language=Kotlin]
    var array: Array<String> = arrayOf("string", "array")
    takeArray(array) // array is treated as platform type
  \end{lstlisting}

\subsubsection{Interference between Kotlin keywords and Java identifiers}
  There are a few keywords, such as \textit{in} or \textit{is}, that do not exist in Java, therefore they are valid names for variables or similar identifiers. If there is Java code using those keywords, it is still possible to interact with it using the backtick (`) character \cite{interop-escaping-identifiers}. In the following example, there is a method of a Java class called \textit{in} we want to access:
\begin{lstlisting}[language=Kotlin]
    var salesman = Salesman("freddy", 1300)
    salesman.`in`(list)
\end{lstlisting}

\subsection{Call Kotlin in Java}
  Just as Kotlin can create instances of Java classes, Java can also create and use instances of Kotlin classes \cite{interop-java}.

\subsubsection{Kotlin properties in Java}
  If you want to access a Kotlin class from Java, you need to use Java syntax, so it is not possible to access Kotlin properties directly as you would in Kotlin. To bridge this gap, Kotlin properties are compiled into a private field, along with corresponding getter and setter methods \cite{interop-properties}. However if the Kotlin property is final, no setter method will be created. For example, consider a simple property in the SalesPerson class:
  \begin{lstlisting}[language=Kotlin]
    var name: String
  \end{lstlisting}
  This will compile to the following components in Java:
  \begin{lstlisting}[language=Java]
    private String name;
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
  \end{lstlisting}
  If the getter or setter of a Kotlin property is declared with restricted visibility, such as private or protected, the Kotlin compiler will respect this when generating the corresponding Java methods, thereby limiting their accessibility.

\subsubsection{Null safety}
  If a public Kotlin function is called from Java, it is possible to pass any object to that function, even if the type is non-nullable in Kotlin. To retain null safety, Kotlin generates checks for those functions and throws a NullPointerException if the value is indeed null \cite{interop-java-null-safety}.

\subsubsection{Package-level function}
  Package-level functions are functions in a class, wich are defined outside of classes, thus are not dependent on an object. Thouse functions including extension functions will be converted to a static methods inside of a new Java class \cite{interop-package-level-func} named by the Kotlin file the function oriented from, because in Java methods outside an class are not prohibited. For example, we have a Kotlin file with the name 'SalesPerson.kt' inside of the package 'org.company' with the follwing package-level method:
  \begin{lstlisting}[language=Kotlin]
    // SalesPerson.kt
    package org.company

    fun createDefault(name: String) { ... }

    class SalesPerson(var name: String, var salary: Int) { ... }
  \end{lstlisting}
  The class will be accessable just like normal, but the createDefault function is in a seperate class called 'SalesPersonKt.class':
  \begin{lstlisting}[language=Java]
    // create instance as expected
    new org.company.SalesPerson("Carl", 4200);
    // createDefault in other class
    org.company.SalesPersonKt.createDefault("Carl");
  \end{lstlisting}
  We can choose a name for the generated class with the '@file:JvmName("Example")' annotation inside the Kotlin file:
\begin{lstlisting}[language=Kotlin]
    // SalesPerson.kt
    @file:JvmName("Example")
    package org.company
    ...
  \end{lstlisting}
  \begin{lstlisting}[language=Java]
    // createDefault in Example
    org.company.Example.createDefault("Carl");
\end{lstlisting}
  If multiple classes use the same name, the compiler would normally throw an error. However, by adding the @file:JvmMultifileClass annotation to all of them, all package-level functions with the same class name are combined into a single generated class \cite{interop-package-level-func}.

\subsubsection{Instance fields}
  In Java, it is possible to access public attributes without using getter and setter methods. This kind of direct access is prohibited in Kotlin. However, if the class is accessed from Java, we can add the @JvmField annotation before our property to make it accessible in Java through dot notation \cite{interop-instance-fields}. The field will have the same visibility as the property in Kotlin \footnote{This does not apply to private properties.}.
  This example demonstrates how to use the annotation.
  \begin{lstlisting}[language=Kotlin]
    class SalesPerson (@JvmField var name:String) {}
  \end{lstlisting}
\begin{lstlisting}[language=Java]
    public void example() {
SalesPerson person = new SalesPerson("Carl");
System.out.println(person.name); // prints 'Carl'
    }
\end{lstlisting}

  Functions in companion or named objects can also be marked as static for Java interoperability using the same annotation \cite{interop-static-fields}; however, this topic is beyond the scope of this paper.

\subsection{Interoperability with JavaScript}
  Besides interoperability with Java, Kotlin also supports interoperability with JavaScript \cite{interopjs}, a scripting language that runs in both the browser and on Node.js servers. To achieve this, you need to create a Kotlin/JS project and compile it with Gradle, a build automation tool commonly used in the Kotlin and Java ecosystems \cite{gradle}, into .js files, which can then be used like regular JavaScript files. Unlike Kotlin/Java interoperability, a Kotlin/JS project requires more setup due to the Gradle build system and the specialized Kotlin-to-JavaScript compiler. However, the Kotlin documentation \cite{interopjs} provides a step-by-step setup guide. With this setup, it is possible to use JavaScript libraries or the DOM API \cite{interopjs-dom} for web development using the familiar Kotlin syntax, thus making it a valid alternative to plain JavaScript. Furthermore, Gradle provides features that improve the workflow and simplify the development process.


\section{Multiplatform development}
	\subsection{Expected and actual declarations}
	\subsection{Hierarchical project structure}

\section{Android}
	This sections concentrates on the benefits Kotlin has in the Android enviorment and gives examples based on the salesperson example from New Language Constructs along the way.
\subsection{Android KTX}

\subsection{Jetpack Compose}
  TODO(
  Kotlin based Ui Tool Kit 
  JC automaticly updates Ui hierarchy
  functions with @Composable /composables
  )
\subsection{Coroutines}
  Now imagine we want to create an app where users can see the sales volume of a certain salesperson live. To achieve this, we would need to check the sales volume every second, which would freeze our app every second until the data of the salesperson is successfully downloaded. So, the smartest solution would be to use multithreading for this process.

  What are threads? -> explenation ... todo
  best case with graphic

  \begin{lstlisting}[language=Java, title={Java Background Threads}]
  new Thread(new Runnable() { //opens a new thread
      public void run() {
          double sales = getSalesVolume();
          runOnUiThread(new Runnable() { //switches to main thread
              public void run() {
                  textView.setText(sales.toString());
              }
          });
      }
  }).start();
  \end{lstlisting}
  In Kotlin, threads are called coroutines, and they are not only easy to read, as you will see below, but are also very lightweight, which means we can run far more Kotlin coroutines than Java threads before running out of memory or losing too much time.
  So, we could check thousands of sales personnel at once without running out of memory.
  \begin{lstlisting}[language = Kotlin, title = Kotlin Coroutines]
  GlobalScope.launch { //opens a new thread
      val sales = getSalesVolume() 
      withContext(Dispatchers.Main) { //switches to main thread
          textView.text = sales 
      }
  }
  \end{lstlisting}

\subsection{Extensions}


\section{Conclusion}
Kotlin is a modern programming language that builds upon Java's foundation, offering a concise syntax, improved class structures, and innovative features such as null safety. Its seamless interoperability with Java and JavaScript makes it an excellent choice for projects requiring integration with existing codebases. Kotlin's support for multiplatform development, particularly in Android, positions it as a powerful tool for developers seeking to create cross-platform applications.

While this paper provides an introduction to Kotlin, it only scratches the surface of its capabilities. Advanced features such as smart casts, delegation, and destructuring declarations further enhance Kotlin's appeal.
Kotlin also embraces functional programming paradigms, inspired by languages like Haskell. It supports higher-order functions, lambda expressions, and immutability, enabling developers to write expressive and concise code. These features allow developers to adopt a functional style while still benefiting from Kotlin's object-oriented capabilities.

These features, combined with its modern design and developer-friendly syntax, make Kotlin a compelling choice for both new and experienced developers.

\newpage
\printbibliography[]

% End of Documment











\newpage
\section{TODO}

  \subsection{General}
    \begin{itemize}
      \item Add citations
      \item Fix formatting (especially indentation in the code snippets)
    \end{itemize}
    
  \subsection{Basic Syntax}
    \begin{itemize}
      \item Example for Top-Level Functions
      \item Explain the absence of static methods (out of scope for introduction?) (use \texttt{@JvmStatic} annotation for interoperability)
    \end{itemize}

  \subsection{Interoperability}
    \begin{itemize}
      \item Use of annotations (e.g. \texttt{@JvmStatic}, \texttt{@JvmField}, \texttt{@JvmName}, \texttt{@JvmOverloads}) (out of scope for introduction?)
      \item Compile to other languages (e.g. JavaScript, Native) (out of scope for introduction?)
    \end{itemize}

  \subsection{New Features}
    \begin{itemize}
      \item Extension functions (not as important)
      \item This expression (interesting, also not too long)
      \item Destructuring declarations
      \item Infix notation for functions
      \item \textit{if} and \textit{when} as expressions (not as important, only if it fits)
    \end{itemize}

  \subsection{Multiplatform development}
  
  \subsection{Android}
    \begin{itemize}
      \item Discuss Kotlin's advantages for Android development
    \end{itemize}

  \subsection{Presentation}
  \begin{itemize}
    \item Line numbers for slides
    \item readability -> light mode
  \end{itemize}

\end{document}