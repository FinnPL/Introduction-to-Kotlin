\documentclass[a4paper, 11pt]{article}
\input{config.tex}

\title{\huge \bfseries Introduction to Kotlin}
\author{
  Christian Konersmann, Finn Paul Lippok, Paul Lukas \\ 
  \\
  RWTH Aachen University, Germany \\
  \texttt{\{christian.konersmann,finn.lippok,paul.lukas\}@rwth-aachen.de}
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
  This paper is an introduction to Kotlin, a statically typed, object-oriented programming language designed to be fully interoperable with Java and the Java Virtual Machine (JVM).
  Kotlin offers a concise syntax, functional programming paradigms, and safety improvements compared to Java. In 2019, Google announced that Kotlin replaced Java as their preferred language for Android development.
\end{abstract}

\section{Introduction}
  Introduction, motivation, and goals of this paper.
  This paper assumes that the reader is familiar with the fundamentals of Java.
  This paper was written as part of the \textit{Proseminar: Advanced Programming Concepts}.
\section{Basic Syntax}
  This section will cover the basic syntax of Kotlin and highlight the changes compared to Java.
  The goal of this section is to provide a brief overview, focusing on the most important differences.

\subsection{Main Method}
  The main method is the entry point of every Java and Kotlin program.
  Java enforces object-oriented programming, thus requiring the main method to be declared inside a class.
  For the main method to be directly executable, the method must be declared as static and public.
  %If the main method were non-static, it would require an instance of the class to be created before it could be called, which in turn would require code execution before the main method could be called, thus creating a circular dependency.
  % ^ relevant? i would think so
  \begin{lstlisting}[language=Java,title={Java main method}]
public class Main {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
}
\end{lstlisting}
  Kotlin, on the other hand, does not require methods to be declared inside a class, allowing for a more functional programming style with top-level functions.
  These top-level functions can be called directly without the need to create an instance of a class, similar to static methods in Java\footnote{When compiling Kotlin to Java bytecode, top-level functions are compiled to static methods in a class named after the file name.} but without class affiliation.
  Kotlin further reduces boilerplate code by changing the default visibility of everything to public and allowing the main method to be declared without arguments passed as an array.
  Some further basic syntactical changes include making the semicolon optional and introducing the \textit{fun} keyword for defining functions.
  These changes lead to a more concise and readable main method and syntax in general.
\begin{lstlisting}[language=Kotlin,title={Kotlin main method}]
fun main() {
  println("Hello, World!")
}
\end{lstlisting}

\subsection{Type Declaration}
  In Kotlin, a variable declaration starts with the keyword \textit{val} for immutable variables or \textit{var} for mutable variables, similar to Java's \textit{final} and non-final variables.
  The type of a variable is declared after the variable name, separated by a colon.
\begin{lstlisting}[language=Java,title={Java data types}]
    final String name = "John Doe";
    int age = 42;
  \end{lstlisting}
  \begin{lstlisting}[language=Kotlin,title={Kotlin data types}]
    val name: String = "John Doe"
    var age: Int = 42
  \end{lstlisting}

\subsection{Type Inference}
  Kotlin also supports type inference, allowing the compiler to infer the type of a variable based on its initializer.
  \begin{lstlisting}[language=Kotlin]
    val name = "John Doe" // type is inferred as String
    var age = 42 // type is inferred as Int
  \end{lstlisting}

\subsection{Method Declaration}
  Similar to java. void = Unit which is optional.
  \begin{lstlisting}[language=Java,title={Java method declaration}]
    public int add(int a, int b) {
      return a + b;
    }
  \end{lstlisting}
  \begin{lstlisting}[language=Kotlin,title={Kotlin method declaration}]
    fun add(a: Int, b: Int): Int {
      return a + b
    }
  \end{lstlisting}

\subsection{Everything is an Object}
  In Kotlin, everything is an object, including primitive types and functions.

\section{New Language Constructs}
  This section focuses on the most important new language constructs that are not present in Java. 
  This section will illustrate Kotlin's advantages using a list of salespersons as an example and comparing it to Java.
  The example should represent a linked list of salespersons containing multiple attributes.
\subsection{Classes}
  In Java and Kotlin, classes are declared using the \textit{class} keyword. They can contain attributes, methods, and constructors.
  In this example, we will declare a class to hold information about a salesperson.
\begin{lstlisting}[language=Java,title={Java Class Declaration}]
public class SalesPerson {
  private final String name;
  private final int commissionRate;
  private double salesVolume;
  
  public SalesPerson(String name, int commissionRate, double transferAmount) {
      this.name = name;
      this.commissionRate = commissionRate;
      this.salesVolume = transferAmount;
    }
  }
\end{lstlisting}
  Kotlin improves upon Java by allowing the constructor to be declared directly within the class definition. As a reminder, public is the default visibility in Kotlin. In addition, classes are also final by default, meaning they cannot be inherited from unless explicitly declared as open.
  Furthermore, Kotlin allows for the declaration of attributes and their visibility directly within the constructor by adding the \textit{val} or \textit{var} keyword and the private keyword, resulting in a syntax very similar to Java records.
\begin{lstlisting}[language=Kotlin,title={Kotlin Class Declaration}]
  class SalesPerson(val name: String, private val commissionRate: Int, transferAmount: Double = 0.0) {
    var salesVolume: Double = transferAmount
  }
\end{lstlisting}
  In this example, both \textit{name} and \textit{commissionRate} are attributes, while \textit{transferAmount} is a normal constructor parameter. These constructor parameters can be used to initialize attributes of the class.
  It is still possible to declare attributes outside of the constructor, like \textit{salesVolume} in this example.
  In addition, Kotlin allows for default values for parameters in constructors and functions, which would require overloading in Java.
  
  %named parameters
\subsection{Properties}
\subsection{String Interpolation}
\subsection{Extension functions}

\subsection{Null Safety}
  Whenever a method or an attribute is called on a null reference in Java, a NullPointerException (NPE) is thrown. The concept behind Null Safety aims to reduce the occurrence of such NPEs. This is achieved through the advanced type system of Kotlin, which distinguishes between nullable and non-nullable types. This guarantees that variables of a non-nullable type can never be null. Unlike Java, this is enforced by the compiler at compile-time, therefore reducing possible sources of NPEs and enhancing the readability and robustness of the code. At runtime, both types are treated the same.
  
  By default, all types in Kotlin are non-nullable, meaning variables cannot hold a null value unless explicitly specified. To allow nullability, a question mark is appended to the type declaration.\footnote{This applies to both mutable and immutable variables.}

  \begin{lstlisting}[language=Kotlin]
    var a: String = "a is non-nullable"
    var b: String? = "b is nullable"
  \end{lstlisting}
  
\subsubsection{Null Safety Operators}
  When working with nullable types, you cannot directly access properties or methods because the value could be null, potentially causing an NPE. Whenever a nullable type is used, the value must be checked in some way to prevent the program from encountering an NPE. To avoid excessive use of if statements, Kotlin provides the safe call operator as a shortcut.

  The \textit{safe call operator} consists of the characters \texttt{?.} and is used when accessing a property or method of a nullable object. If the object is null, the operator returns null without evaluating the rest of the expression. Otherwise, the expression is evaluated as usual. Practically, this operator extends the already familiar dot notation for attributes and methods of objects. In principle, the safe call operator can also be seen as a shorthand for an if statement. By using the safe call operator, the code becomes much more readable and concise. With the reduced complexity, it is also less error-prone.

  \begin{lstlisting}[language=Kotlin,title={Using the safe call operator in comparison to an if statement}]
    var couldBeNull: String? = null
    println(if (couldBeNull == null) null else couldBeNull.length)
    println(couldBeNull?.length)    // Safe call operator
  \end{lstlisting}
  We can use multiple safe call operators and chain them together. The compiler evaluates the expression from left to right, checking each operator sequentially. If any value is null, the entire expression evaluates to null.
  Furthermore, the operator can also be used on the left side of an assignment. If the safe call operator evaluates to null, the assignment will be skipped. Otherwise, the value will be assigned as usual.
  % Wir sollten das Beispiel anpassen und die Formulierung in den zwei Absätzen drüber checken
  \begin{lstlisting}[language=Kotlin]
    var age: Int? = rwth?.ceo?.age // chained safe call operators
    rwth?.ceo?.age = 20 // assignment with chained operator
  \end{lstlisting}

  The \textit{Elvis operator} (\texttt{?:}) is an enhanced version of the safe call operator, offering a more concise way to handle null values. If the expression on the left side of the Elvis operator evaluates to null, instead of returning null like the safe call operator, it returns a default value specified on the right side. As a result, the Elvis operator is commonly used alongside the safe call operator. In essence, both operators serve as simplified alternatives to if statements. This shorthand improves code readability and maintainability. % improve paragraph
  \begin{lstlisting}[language=Kotlin,title={Using the Elvis operator in comparison to an if statement}]
    var couldBeNull: String? = null
    println(if (couldBeNull == null) 0 else couldBeNull.length)
    println(couldBeNull?.length ?: 0)   // Elvis operator
  \end{lstlisting}
  \hfill \break
  Java does not have a safe call operator, an Elvis operator, or any equivalent feature. To prevent NPE in Java, you have to explicitly check with an if-statement for the value to not be null. This is very inconvenient, hard to read, and prone to errors.
  \begin{lstlisting}[language=Java,title={Prevent NPE in Java}]
    String couldBeNull = null;
    if (couldBeNull == null) System.out.println("null");
    else System.out.println(couldBeNull.length());
  \end{lstlisting}
  \hfill \break
  Both the safe call operator and the Elvis operator are treated by the compiler as the if statements mentioned in the examples above. It simply makes the code significantly shorter and easier to read. % Soll ich das mit java-byte code belegen?

\subsubsection{Safe casts}
  Safe casts are another way to handle nullable objects. But in order to understand the Safe cast, we have to look at how Kotlin handles type casts in general. The principle behind casting is the same as in java, only the syntax is diffrent. Kotlin uses the \texttt{as} keyword behind the expression followed by the new type to cast one type into another. In java the new type had to be written in round brakets before the expression.
  \begin{lstlisting}[language=Kotlin,title={Casting in Kotlin}]
    var a: Any = "Replace this example"
    var b:String = a as String
  \end{lstlisting} % Beispiel für casting in java adden? Sollte eig aus Vorlesung mehr als bekannt sein tbh und darauf sollte auch nit der Schwerpunkt liegen
  \textit{Safe cast} is used to prevent a ClassCastException when a given object does not match the target type. The safe cast operator extends the standard cast keyword by adding a question mark and is applied in the same manner as a regular cast. If the object is not of the target type, instead of throwing an exception, the expression evaluates to null. This significantly simplifies casting, eliminating the need to catch potential exceptions or perform type checks \footnote{Type checks in Kotlin are performed using the is and !is keywords, which function similarly to the instanceof keyword in Java.} beforehand. The functionality of the operator can also be replicated using if statements, further demonstrating its benefits for code readability and maintainability.
  \begin{lstlisting}[language=Kotlin,title={Usage of the safe cast operator in comparisopn to an if statement}]
    var str:Any? = "Also replace *this* example"
    var a:Int? = str as? Int // evaluates to null
    var b:Int? = if (str is Int) str else null // no need for the `as Int` here due to smart casting
  \end{lstlisting}
  But the safe cast operator is like the other two null safety operators very usefull at handling nullable objects. If the argument of the safe cast is null, instead of throwing a NPE the expression evaluates to null as well. Therefore the code is less prone to errors. If you want to enhance null safety, you can combine the safe cast operator with the Elvis operator to provide a fallback value when the safe cast operator returns null due to a type mismatch or a null reference.
  \begin{lstlisting}[language=Kotlin,title={Usage of the safe cast operator on a nullable value}]
    var str:Any? = null
    var a:Int? = str as? Int // evaluates to null
  \end{lstlisting}
    As mentioned above there is nothing like the safe cast operator in Java. If you wanted to achieve the same result, you either had to catch the ClassCastException or  had to check for nullability before casting. This once again demonstrates how Kotlin's concise and well-designed syntax significantly simplifies programming compared to Java.
  \begin{lstlisting}[language=Java,title={Functionality of safe call operator in java}]
    Object obj = null;
    String str = null;
    if (obj != null && obj instanceof String s) str = s;
  \end{lstlisting}

  \subsubsection{Not-null assertion}
    The \textit{not-null assertion operator} consists of two exclamation marks (!!). It is used to convert nullable types to non-nullable types by instructing the compiler to treat the value as non-null. However, if the value is actually null, a NullPointerException (NPE) will be thrown. This operator contradicts the concept of null safety and should only be used when the programmer is certain that the value cannot be null, but the compiler is unable to guarantee it.
  \begin{lstlisting}[language=Kotlin,title={Usage of the not-null assertion}]
    var couldBeNull: String? = null
    var b: String = couldBeNull!!
  \end{lstlisting}
  % Compareison with Java cast / assertion ??

  \subsubsection{Nullable receiver}
    We have already covered extension functions in the chapter on Classes. As a brief reminder, extension functions are external additions to a class that introduce new methods, which can be called on an instance of the class using dot notation.

    Since extension functions are not actually part of the class itself but merely an extension that can be called using dot notation, it is possible for the object to be null while still being able to call the extension method. To achieve this, the function must have a so-called \textit{nullable receiver} type, which is indicated by a question mark after the class the extension function is defined for. As a result, the method remains accessible even if the object is null. This allows values of a nullable type to be accessed without checking for null beforehand, as the null case is handled within the method itself.
    \begin{lstlisting}[language=Kotlin,title={Usage of an extension function}]
      /** TODO: Insert example here
      * sollte zeigen wie man nullable receiver definiert
      * sollte zeigen, wie man damit null safety sichert in methode
      */
    \end{lstlisting}

  \subsubsection{Collections of nullable types}
  \begin{itemize}
    \item let function
    \item .filterNotNull() function
  \end{itemize}
  Diesen Abschnitt können wir weglassen, wenn wir zu viele Seiten haben, das ist kein wichtiges Thema. Alternativ kann man dies kurz in einer Fußnote o.ä. erwähnen.

\section{Interoperability}

\section{TODO}

\subsection{Interoperability}
  \begin{itemize}
    \item Explain the interoperability between Java and Kotlin (e.g. Using Java libraries in Kotlin)
    \item Use of annotations (e.g. \texttt{@JvmStatic}, \texttt{@JvmField}, \texttt{@JvmName}, \texttt{@JvmOverloads}) (out of scope for introduction?)
    \item Compile to other languages (e.g. JavaScript, Native) (out of scope for introduction?)
  \end{itemize}

\subsection{New Features}
\begin{itemize}
  \item Properties (Getters, Setters)
  \item Extension functions (not as important)
  \item This exrpession
  \item Destructuring declarations
  \item \textit{if} and \textit{when} as expressions (not as important, only if it fits)
\end{itemize}

\section*{Acknowledgements}
  We would like to thank our instructor.

\end{document}
