\documentclass[a4paper,11pt]{article}
\input{config.tex}

\title{\huge \bfseries Introduction to Kotlin}
\author{
  Christian Konersmann, Finn Paul Lippok, Paul Lukas\\[1ex]
  RWTH Aachen University, Aachen, Germany\\
  \texttt{\{christian.konersmann,finn.lippok,paul.lukas\}@rwth-aachen.de}\\
  \and
  Proseminar: Advanced Programming Concepts\\
  Organiser: Prof.\ Dr.\ Jürgen Giesl\\
  Supervisor: Jan-Christoph Kassing
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This paper introduces Kotlin, a statically typed, object-oriented programming language designed to be fully interoperable with Java and the Java Virtual Machine (JVM). It focuses on Kotlin's concise syntax, advanced features such as null safety, and extensive multiplatform development capability. These features make Kotlin a modern and powerful programming language.
\end{abstract}

\section{Introduction}
Kotlin is a modern programming language developed by JetBrains, a renowned software development company. Designed as a safer and more concise alternative to Java, Kotlin offers full interoperability with Java, allowing developers to leverage existing Java libraries and frameworks while benefiting from Kotlin's modern features. Its clean and expressive syntax has made it increasingly popular, particularly in Android development. In fact, Google announced Kotlin as its preferred language for Android app development in 2019~\cite{intro-google}. Beyond Android, Kotlin supports multiplatform development, enabling developers to build applications for the server, desktop, web, and iOS from a shared codebase~\cite{intro-multiplatform-dev}.
This paper presents an overview of Kotlin’s concise syntax and highlights key language features that illustrate its advantages over Java. It assumes a basic understanding of Java and begins by examining core syntactic differences between Kotlin and Java, followed by an introduction to concepts such as null safety and seamless Java interoperability. The paper concludes with a discussion of Kotlin’s multiplatform capabilities, with particular emphasis on its application in Android development.

\section{Basic Syntax}
This section covers the basic syntax of Kotlin and highlights its differences compared to Java. The goal is to provide a concise overview focused on the most important distinctions.

\subsection{Program Entry Point and Method Declaration}\label{sec:program-entry-point}
The \textit{main} method is the entry point of any Java or Kotlin program~\cite{program-entry-point}. Java enforces object-oriented programming, thus requiring the \textit{main} method to be declared within a class. For the \textit{main} method to be directly executable, it must be \textit{public} and \textit{static},\footnote{If the \textit{main} method were non-static, it would require an instance of the class before it could be run, leading to a circular dependency.} as shown below:

\begin{lstlisting}[language=Java, title={Java main method}]
public class Main {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
}
\end{lstlisting}

Kotlin, on the other hand, does not require methods to be declared inside a class, allowing for a more functional programming style with top-level functions. These top-level functions can be called directly without the need to instantiate a class~\cite{kotlin-functions-scope}, functioning similarly to static methods in Java,\footnote{When compiling Kotlin to Java bytecode, top-level functions are compiled as static methods in a class named after the file.\ (\autoref{sec:package-level-func})} but without an explicit class affiliation. Kotlin further reduces boilerplate by having \textit{public} as the default visibility~\cite{visibility-modifiers} and allowing the \textit{main} method to omit arguments passed as an array~\cite{program-entry-point}. Also, semicolons are optional, and Kotlin introduces the \textit{fun} keyword for defining functions~\cite{functions}, resulting in a concise and readable syntax, as shown here:

\begin{lstlisting}[language=Kotlin, title={Kotlin main method}]
fun main() {
  println("Hello, World!")
}
\end{lstlisting}

\subsection{Variable Declaration}\label{sec:variables}
Variables in Kotlin are declared using the keyword \textit{val} for immutable variables or \textit{var} for mutable variables~\cite{variables}, similar to Java's \textit{final} and non-final variables. The type is declared after the variable name, separated by a colon:

\begin{lstlisting}[language=Java, title={Java data types}]
final String name = "John Doe";
int age = 42;
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin data types}]
val name: String = "John Doe"
var age: Int = 42
\end{lstlisting}

\subsection{Type Inference}
Kotlin supports type inference, allowing the compiler to infer a variable's type based on its initializer or usage~\cite{type-inference}.
Unlike many functional programming languages such as Haskell, which rely on unification for type inference, Kotlin uses a different approach called constraint solving~\cite{type-constraints}.
This approach allows for type inference with subtyping.
However, a detailed discussion of its internal workings is out of scope for this paper.

\begin{lstlisting}[language=Kotlin]
val name = "John Doe" // type is inferred as String
var age = 42 // type is inferred as Int
\end{lstlisting}

\subsection{Return Type Declaration}
Similar to variable declaration (\autoref{sec:variables}), a method's return type is declared after the method name and parameters, separated by a colon~\cite{functions}. The equivalent of \textit{void} in Java is \textit{Unit} in Kotlin~\cite{builtin-types-unit,kotlin-stdlib-unit}, which can be omitted if no value is returned.

\begin{lstlisting}[language=Java, title={Java method declaration}]
public int add(int a, int b) {
  return a + b;
}
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin method declaration}]
fun add(a: Int, b: Int): Int {
  return a + b
}
\end{lstlisting}

\subsection{Everything is an Object}
In Kotlin, there are no primitive types.\footnote{Certain types may be optimized to use Java primitives at runtime for performance reasons.} All types are objects and inherit from the \textit{Any} class~\cite{basic-types}. This approach creates a more consistent object-oriented programming model and eliminates the need for wrapper classes.

\begin{lstlisting}[language=Java, title={Java Integer Wrapper}]
Integer.valueOf(42).hashCode();
\end{lstlisting}

\begin{lstlisting}[language=Kotlin, title={Kotlin direct usage of Int}]
42.hashCode()
\end{lstlisting}

Furthermore, functions in Kotlin are also treated as objects~\cite{higher-order-functions}, enabling higher-order functions and functional programming paradigms. As a result, functions can be passed as arguments, returned from other functions, and assigned to variables.

\section{Classes}
In both Java and Kotlin, classes are declared using the \textit{class} keyword~\cite{classes} and can contain attributes, methods, and constructors. In the example below, we declare a class to represent a salesperson:

\begin{lstlisting}[language=Java, title={Java Class Declaration}]
public class SalesPerson {
  private final String name;
  private final int commissionRate;
  private double salesVolume;
  
  public SalesPerson(String name, int commissionRate, double transferAmount) {
    this.name = name;
    this.commissionRate = commissionRate;
    this.salesVolume = transferAmount;
  }
}
\end{lstlisting}
Kotlin improves upon Java by allowing the constructor to be declared directly within the class definition~\cite{classes-constructors}. As a reminder, the default visibility in Kotlin is \textit{public}, and classes are also \textit{final} by default, meaning they cannot be inherited from unless explicitly declared \textit{open}. Kotlin also permits the declaration of constructor parameters (as properties) using \textit{val} or \textit{var}, including visibility modifiers~\cite{classes-constructors}, resembling the concise syntax found in Java records:

\begin{lstlisting}[language=Kotlin,title={Kotlin Class Declaration}]
class SalesPerson(val name: String, private val commissionRate: Int, transferAmount: Double = 0.0) {
  var salesVolume: Double = transferAmount
}
\end{lstlisting}

In this example, \textit{name} and \textit{commissionRate} become properties of the class, while \textit{transferAmount} is a constructor parameter used to initialize \textit{salesVolume}. It is still possible to declare attributes outside the constructor. Additionally, Kotlin allows default parameter values in constructors and functions, a feature that would otherwise require method overloading in Java.

\subsection{Properties}
Properties in Kotlin facilitate concise declaration of getters and setters, including their visibility, directly beside the corresponding attribute~\cite{declaring-properties,properties-getters-setters}. Unlike Java, accessing a property in Kotlin via dot notation will internally call the corresponding getter or setter method, ensuring a consistent syntax.
If only the visibility needs to be restricted, the property can be declared as shown below:

\begin{lstlisting}[language=Kotlin, title={Private setter}]
var salesVolume: Double = transferAmount
  private set
\end{lstlisting}

For more complex logic, custom getters and setters can be defined inline~\cite{properties-getters-setters}. The \textit{field} keyword refers to the underlying attribute:

\begin{lstlisting}[language=Kotlin, title={Custom accessors}]
var salesVolume: Double = transferAmount
  private set(value) {
    if (value < 0)
      throw IllegalArgumentException("SV must be positive")
    field = value
  }
\end{lstlisting}

Kotlin also supports computed properties, which do not store a value but compute it on access via a custom getter~\cite{properties-getters-setters}. This approach mirrors writing a getter method in Java without a backing field:

\begin{lstlisting}[language=Kotlin, title={Computed Property}]
val commission: Double
  get() = salesVolume * commissionRate
\end{lstlisting}

\section{String Interpolation}
In Java, variables are typically formatted into strings using the \textit{String.format()} method or by concatenation with the \texttt{+} operator. Kotlin introduces a more readable mechanism called string interpolation~\cite{string-concatenation}, allowing variables and expressions to be directly embedded within a string by prefixing them with a \texttt{\$} sign, and enclosing expressions in curly braces:

\begin{lstlisting}[language=Kotlin, title={String Interpolation}]
fun printSalesPerson() {
  println("Name: $name, Sales in USD: ${salesVolume * 1.2}")
}
\end{lstlisting}

\section{Extension Functions}\label{sec:extension-functions}
Extension functions enable the declaration of new methods for a class without modifying the class's source code.
Data encapsulation remains intact, as extension functions can only access the public members of the class.
This feature is particularly useful when adding utility methods to existing classes you cannot modify, such as third-party libraries:

\begin{lstlisting}[language=Kotlin, title={Extension Function}]
// Extension function outside of the class
fun SalesPerson.print() {
  println("$name: $salesVolume sold")
}

fun main() {
  val carl = SalesPerson("Carl", 1200)
  carl.print() // Calling the extension function
}
\end{lstlisting}

\section{Null Safety}
Whenever a method or attribute is accessed on a null reference in Java, a \texttt{NullPointerException} (NPE) is thrown. Kotlin eliminates this risk with a null safety system that distinguishes between nullable and non-nullable types~\cite{nullsafety,nullsafety-nullable-types}. By default, all types in Kotlin are non-nullable, meaning variables cannot hold a null value unless explicitly declared with a question mark:
Kotlin enforces this distinction at compile time, requiring developers to handle nullable types explicitly. At runtime, both types are treated the same.
\begin{lstlisting}[language=Kotlin]
var a: String = "a is non-nullable"
var b: String? = "b is nullable"
\end{lstlisting}

\subsection{Null Safety Operators}
When working with nullable types, you cannot directly access properties or methods, because the reference could be \texttt{null}, potentially causing an NPE\@.
In Java, this is typically handled with an if check, as shown in the following example:
\begin{lstlisting}[language=Java]
  private final SalesPerson supervisor;

  public void printSupervisor() {
    if (supervisor == null) System.out.println("null");
    else System.out.println(supervisor.name);
  }
\end{lstlisting}

This approach is also available in Kotlin, where checking for a null value in an if statement automatically casts the type to a non-nullable type within the scope of the statement~\cite{nullsafety-if-condition}.\footnote{This feature is known as smart casting, where the compiler automatically casts the variable to a more specific type when it can guarantee the safety of the cast.}
However, Kotlin provides convenient shortcuts for handling nullable types by using Null safety operators.

\subsubsection{Safe Call Operator}
The safe call operator \texttt{?.}\ allows you to access properties or methods of an object only if it is non-null, thereby reducing the need for explicit null checks~\cite{nullsafety-safe-call}.
If the object is \texttt{null}, the expression safely evaluates to \texttt{null}, avoiding an NPE\@.
Otherwise, it evaluates as expected, granting access to the object's attributes or methods.
Essentially, this operator enhances the standard dot notation by incorporating null safety. 

\begin{lstlisting}[language=Kotlin]
val supervisor: SalesPerson? = null
fun printSupervisor() {
  println(supervisor?.name)
}
\end{lstlisting}

Multiple safe calls can be chained~\cite{nullsafety-safe-call}, and if any segment is \texttt{null}, the entire chain evaluates to \texttt{null}.
Furthermore, Safe calls can also be used on the left side of an assignment. If the safe call operator evaluates to null, the assignment will be skipped.

\begin{lstlisting}[language=Kotlin]
// Chained safe call operators
var volume: Double? = supervisor?.supervisor?.salesVolume
// Assignment with a chained operator
supervisor?.supervisor?.salesVolume = 0.0
\end{lstlisting}

\subsubsection{Elvis Operator}
The Elvis operator \texttt{?:} is an enhanced version of the safe call operator, offering a more concise way to handle \texttt{null} values. If the expression on the left side evaluates to \texttt{null}, it returns a default value specified to the right side of \texttt{?:}~\cite{nullsafety-elvis}:

\begin{lstlisting}[language=Kotlin]
fun printSupervisor() {
  println(supervisor?.name ?: "No supervisor")
}
\end{lstlisting}

When compiling to Java, both the safe call operator and the Elvis operator are treated by the compiler as if statements. These operators simply make the code significantly shorter and easier to read, therefore increasing the maintainability as well.

\subsubsection{Not-Null Assertion Operator}
The not-null assertion operator (\texttt{!!}) converts a nullable type to a non-nullable type, instructing the compiler to treat the value as non-null~\cite{nullsafety-assertion}. However, if the value is actually \texttt{null}, a \texttt{NullPointerException} will be thrown.
This operator contradicts the concept of null safety and should only be used when the programmer is certain that the value cannot be null, but the compiler is unable to guarantee it.


\begin{lstlisting}[language=Kotlin, title={Usage of the not-null assertion}]
var possiblyNull: String? = null
var b: String = possiblyNull!!
\end{lstlisting}

\subsection{Nullable Receiver}
Nullable receivers refer to extension functions (\autoref{sec:extension-functions}) that can be called on nullable objects~\cite{nullsafety-nullable-receiver}. 
A normal extension function cannot be called on a nullable type, as the compiler cannot guarantee that the object is not null.
However, it is possible to define an extension function that can be called on nullable types by implementing a so-called \textit{nullable receiver}, which is indicated by a question mark after the class name in the method declaration. 
By handling the null case within the method itself, the method remains accessible even if the object is null.
The following example demonstrates how to define and properly use an extension function with a nullable receiver type.

\begin{lstlisting}[language=Kotlin,title={Usage of an extension function}]
// define the extension function
fun SalesPeron?.print() {
    if (this == null) return println("This person dose not exist.")
    return println("$name: $salesVolume sold")
}
// use the extension function
var sales: SalesPeron? = null
sales.print() // This person dose not exist.
sales = SalesPeron("Carl", 1200)
sales.print() // Carl: 0.0 sold
\end{lstlisting}

\section{Interoperability}

This chapter focuses on interoperability between Java and Kotlin. In this context, interoperability refers to the seamless compatibility between the two languages. Kotlin was designed to integrate smoothly with Java code and vice versa, making it easy to use both within the same project.

\subsection{Call Java in Kotlin}
Everything written in Java is accessible in Kotlin~\cite{interop}, making interoperability especially useful when working with Java libraries. There are already countless libraries written in Java that can now be used in Kotlin, eliminating the need to rewrite a library with the same functionality specifically for Kotlin. This applies to both the official Java standard libraries and more specialized external libraries. Additionally, interoperability makes it much easier to migrate existing Java projects to Kotlin, as they do not need to be completely rewritten. This once again shows that Kotlin is a well-thought-out language designed to serve as an improvement over Java.

\subsubsection{Create and access objects}
To illustrate how Java code can be accessed in a Kotlin project, the following example features a Salesman class that stores basic information using getters and setters.
\begin{lstlisting}[language=Java,title={Example Java class}]
public class Salesman {
  private final String name;
  private int salary;
  
  public Salesman(String name, String title, int salary) {
    this.name = name;
    this.salary = salary;
  }

  public String getName() { return name; }
  public int getSalary() { return salary; }
  public void setSalary(int salary) { this.salary = salary; }
}
\end{lstlisting}
If we want to access this class, we can use the familiar Kotlin syntax~\cite{interop} to instantiate the object and access its properties. There is no syntactical difference between accessing a Java class and a Kotlin class. Since there are no explicit getter and setter methods in Kotlin, Java methods following Java's conventions for getters and setters are converted~\cite{interop-getter-setter} into so-called synthetic properties~\cite{interop-synthetic-property}. These can be accessed using Kotlin’s property syntax. If the getters and setters do not follow Java conventions, they can still be accessed as regular methods.
\begin{lstlisting}[language=Kotlin, title={Access a Salesman instance in Kotlin}]
var carl = Salesman("carl mueller", 4500)
println(carl.name) // prints 'carl mueller'
carl.salary = 4600 // sets salary to 4600
carl.setSalary(4600) // alternivly to the above
\end{lstlisting}
Kotlin detects that the name field in the Java class is final, therefore only a getter method will be created. If the field had only a setter, the method would not be converted into a synthetic property, as Kotlin does not support set-only properties~\cite{interop-synthetic-property}.

\subsubsection{Mapped types}
By default, when instances of a Java class are used in Kotlin, they are loaded as Java objects. However, some Java types have a corresponding Kotlin counterpart, these objects are automatically mappped to their equivalent Kotlin counterpart~\cite{interop-mapped-types}. For example, \texttt{java.lang.Integer} is converted to \texttt{kotlin.Int?}~because Java wrapper objects can be null. This applies to all Java wrapper classes and some important types, such as \texttt{java.lang.Object}, which is mapped to \texttt{kotlin.Any!}\footnote{The exclamation mark indicates that this is a platform type. More on this in the next chapter.}. However, all Java primitive types are mapped to their non-nullable Kotlin counterparts, as primitive types cannot be null in Java. For instance, Java's \texttt{int} is converted to \texttt{kotlin.Int}. Additionally, collections like Lists, Maps and Arrays are also converted. For a complete list of all mapped types, consult the official documentation~\cite{interop-mapped-types}. Java's return type \texttt{void} is replaced by Kotlin's \texttt{Unit} type.

\subsubsection{Null safety with Java}
Since Java does not distinguish between nullable and non-nullable types, any object returned from Java code can be null. This contradicts Kotlin's strict null safety concept and would make working with Java objects impractical.
To address this, Kotlin introduces \textit{platform types} for objects created through Java code. If a Java type does not have a direct Kotlin equivalent, as is the case with most Java types, the compiler assigns it a platform type, which is non-denotable.~\cite{interop-null-safety}. This means we cannot explicitly declare or write this type as we do with nullable types using a question mark\footnote{When the compiler needs to report a type-related error, it uses an exclamation mark to indicate the platform type~\cite{interop-platform-notation}.}. With platform types, Kotlin relaxes its strict null safety rules, making their handling similar to Java. However, this increases the risk of NullPointerExceptions.
To demonstrate how this can be used in practice, the previously introduced Java Salesman class has been extended with the following method:
\begin{lstlisting}[language=Java]
public static List<Salesman> createList() {
  List<Salesman>  list = new ArrayList<>();
  list.add(null);
  list.add(new Salesman("Carl", 4200));
  return list;
}
\end{lstlisting}
If we access this method through Kotlin, we get the List containing the two Elements created in Java. Since both objects are created in Java and could be null, they are assigned the platform type, thus the developer can decide if the variable should be nullable or non-nullable.
\begin{lstlisting}[language=Kotlin]  
val list = Salesman.createList()
println(list::class.qualifiedName)
var item: Salesman = list[0]
var nullableItem: Salesman? = list[1]
println(item.name) // allowed but would throw NPE
\end{lstlisting}
If the type is set to non-nullable but the object is actually null, attempting to access its members will result in a NullPointerException, as shown above. Therefore, using nullable types is generally safer.

Some Java compilers use annotations~\cite{interop-nullability-annotations} to specify whether a value is nullable or non-nullable, such as JetBrains' @Nullable or @NotNull annotation~\cite{JetBrains-annotations}. If these annotations are present in the Java code, the compiler assigns the corresponding nullable or non-nullable Kotlin type to the variable instead of a platform type. If we had a method returning a simple string with a @NotNull annotation in our Salesman class, the variable would actually assign the non-nullable type instead of the platform type:
\begin{lstlisting}[language=Java]
public static @NotNull String getString() { return "Not null"; }
\end{lstlisting}
\begin{lstlisting}[language=Kotlin]
val str: String = Salesman.getString() // non-nullable type
\end{lstlisting}

\subsubsection{Java arrays in Kotlin}
In Java, arrays of primitive types can be used to achieve better performance, as they avoid the overhead associated with objects. Kotlin prohibits the direct use of primitive arrays but provides specialized classes for each primitive type instead~\cite{interop-arrays}. The compiler optimizes the code and uses primitive arrays whenever possible. For example, Java's \texttt{int[]} corresponds to Kotlin's \texttt{IntArray}. These classes compile down to actual primitive arrays to minimize object overhead.

Let's assume we have a function in Java that requires a primitive array:
\begin{lstlisting}[language=Java]
public static void takeArray(int[] array) { ... }
\end{lstlisting}
To call this function from Kotlin without unnecessary boxing, we should use \texttt{intArrayOf()} instead of \texttt{arrayOf()}. This ensures that the array compiles down to Java's \texttt{int[]}, avoiding the overhead of boxed Integer objects. Even in for loops, the Kotlin compiler optimizes iteration over primitive arrays, ensuring that no iterator is created~\cite{interop-arrays}. This results in significant performance improvements compared to iterating over an \texttt{Array<Int>}, which would involve additional function calls and object overhead.
\begin{lstlisting}[language=Kotlin]
var array: IntArray = intArrayOf(1, 2, 3)
takeArray(array) // passes int[] to Java function
for (i in array.indices) // no iterator created
    println(array[i]) // no calls to Array's get() or set()
\end{lstlisting}
% Ab hier besser streichen, vllt in einem satz erwähnen, dass es das gibt
In Java, arrays are covariant, meaning an array of a subtype can be assigned to an array of its superclass. This is allowed at compile time, but Java enforces type safety at runtime. If an instance of a type that differs from the array's original type is assigned to it, an ArrayStoreException will be thrown. This happens because mixing different types in the array would break type safety. To counteract this problem, Kotlin simply does not allow this, thus there arrays are invariant~\cite{interop-arrays}. However there is an exception when you need to parse an array to Java, it is allowed for platform types, because Java treats arrays as covariant. If we had a method, that requires an Object array, we could parse a string array of platform type to it.
\begin{lstlisting}[language=Java]
public static void takeArray(Object[] array) { ... }
\end{lstlisting}
\begin{lstlisting}[language=Kotlin]
var array: Array<String> = arrayOf("string", "array")
takeArray(array) // array is treated as platform type
\end{lstlisting}

\subsubsection{Interference between Kotlin keywords and Java identifiers}
There are a few keywords, such as \textit{in} or \textit{is}, that do not exist in Java, therefore they are valid names for variables or similar identifiers. If there is Java code using those keywords, it is still possible to interact with it using the backtick (\texttt{`}) character~\cite{interop-escaping-identifiers}. The following example demonstrates this by accessing a Java method named \textit{in} from Kotlin.
\begin{lstlisting}[language=Kotlin]
var salesman = Salesman("freddy", 1300)
salesman.`in`(list)
\end{lstlisting}

\subsection{Call Kotlin in Java}
Just as Kotlin can create instances of Java classes, Java can also create and use instances of Kotlin classes~\cite{interop-java}.

\subsubsection{Kotlin properties in Java}
Kotlin properties cannot be accessed directly from Java and must be used via standard Java syntax. Therefore, the properties are compiled into a private field, along with corresponding getter and setter methods~\cite{interop-properties}. However, if the Kotlin property is final, no setter method will be created. For example, consider a simple property in the SalesPerson class:
\begin{lstlisting}[language=Kotlin]
var name: String
\end{lstlisting}
This will compile to the following components in Java:
\begin{lstlisting}[language=Java]
private String name;
public String getName() { return name; }
public void setName(String name) { this.name = name; }
\end{lstlisting}
If the getter or setter of a Kotlin property is declared with restricted visibility, such as private or protected, the Kotlin compiler will preserve this visibility when generating the corresponding Java methods.

\subsubsection{Null safety} % change this headline
If a public Kotlin function with a non-nullable parameter is called from Java, a nullable value can be passed to this function from Java. To retain null safety, Kotlin generates checks for those functions and throws a NullPointerException if the value is indeed null~\cite{interop-java-null-safety}.

\subsubsection{Package-level function}\label{sec:package-level-func}
Package-level functions are top-level functions (\autoref{sec:program-entry-point}) which are defined inside a package. These functions including extension functions will be converted to static methods inside a new Java class~\cite{interop-package-level-func} named by the Kotlin file the function oriented from, because in Java methods outside a class are prohibited. For example, consider a Kotlin file named \texttt{SalesPerson.kt} in the package \texttt{org.company}, containing the following package-level method:
\begin{lstlisting}[language=Kotlin]
// SalesPerson.kt
package org.company
fun createDefault(name: String) { ... }
class SalesPerson(var name: String, var salary: Int) { ... }
\end{lstlisting}
The class will be accessible just like normal, but the createDefault function is in a separate class called \texttt{SalesPersonKt.class}:
\begin{lstlisting}[language=Java]
// create instance as expected
new org.company.SalesPerson("Carl", 4200);
// createDefault in other class
org.company.SalesPersonKt.createDefault("Carl");
\end{lstlisting}
The name of the generated class can be set using the \texttt{@file:JvmName("Example")} annotation in the Kotlin file:
\begin{lstlisting}[language=Kotlin]
// SalesPerson.kt
@file:JvmName("Example")
package org.company
...
\end{lstlisting}
\begin{lstlisting}[language=Java]
// createDefault in Example
org.company.Example.createDefault("Carl");
\end{lstlisting}
If multiple classes use the same name, the compiler would normally throw an error. However, by adding the \texttt{@file:JvmMultifileClass} annotation to all of them, all package-level functions with the same class name are combined into a single generated class~\cite{interop-package-level-func}.

\subsubsection{Instance fields}
In Java, it is possible to access public attributes without using getter and setter methods. This kind of direct access is prohibited in Kotlin to maintain code integrity. However, we can add the @JvmField annotation before our property to make it accessible in Java through dot notation~\cite{interop-instance-fields}. The field will have the same visibility as the property in Kotlin\footnote{This does not apply to private properties.}.
This example demonstrates how to use the annotation.
\begin{lstlisting}[language=Kotlin]
class SalesPerson (@JvmField var name:String) {}
\end{lstlisting}
\begin{lstlisting}[language=Java]
public void example() {
SalesPerson person = new SalesPerson("Carl");
System.out.println(person.name); // prints 'Carl'
}
\end{lstlisting}

Functions in companion or named objects can be marked as static to be accessed in Java using the same annotation~\cite{interop-static-fields}, though this topic is beyond the scope of this paper.

\subsection{Interoperability with JavaScript}
Besides interoperability with Java, Kotlin also supports interoperability with JavaScript~\cite{interopjs}, a scripting language that runs in both the browser and on Node.js servers. To achieve this, you need to create a Kotlin/JS project and compile it with Gradle, a build automation tool commonly used in the Kotlin and Java ecosystems~\cite{gradle}, into \texttt{.js} files, which can then be used like regular JavaScript files. Unlike Kotlin/Java interoperability, a Kotlin/JS project requires more setup due to the Gradle build system and the specialized Kotlin-to-JavaScript compiler. However, the Kotlin documentation~\cite{interopjs} provides a step-by-step setup guide. With this setup, it is possible to use JavaScript libraries or the DOM API~\cite{interopjs-dom} for web development using the familiar Kotlin syntax, thus making it a valid alternative to plain JavaScript. Furthermore, Gradle provides features that improve the workflow and simplify the development process.

\section{Multiplatform development}
Kotlin can be compiled not only for the JVM but also to native binaries, eliminating the need for a virtual machine as required by Java. This makes Kotlin suitable for use in embedded systems, where running a large virtual machine is not possible. Furthermore, Kotlin is not only interoperable with Java but can also be compiled to pure JavaScript or WebAssembly, making it a viable option for web development as well. For performance-critical applications, Kotlin is also developing interoperability features for C and Objective-C.
%All those platforms make it ...
All those platforms make it complicated to track the code across them all and keep them uptodate with their different dependencies
%and prevent bugs caused by unupdated code for one platform



%Multiplatform development is a key benefit in Kotlin. By reusing the same code across multibile platforms we can save alot of time writing the code and can concentrate more on the differences between the platforms.

\subsection{Hierarchical project structure}
To simplify the multiplatform development process, Kotlin features a powerful tool called Hierarchical project Structers.
Kotlin’s hierarchical project structure works like a tree of objects with parent-child relationships. Each object (called a source set) contains code and targets also called tags that define which platforms the code should compile to.
For example, if building an app for both Android and Apple, shared code goes into commonMain. Then, platform-specific code goes into androidMain and appleMain, which are child source sets with their own platform tags.
You can go even deeper, splitting appleMain into iOSMain and macOSMain. These middle layers like appleMain are called intermediate source sets, sitting between commonMain and final targets.
When compiling (e.g., for a new iPhone), Kotlin traces the tags through the hierarchy compiling the code togethere along the way. If a required tag is missing or misplaced, the compiler can’t link everything together, and the build will fail.

\subsection{Expected and actual declarations}

Expected and actual declarations in Kotlin work like abstract functions. You use expect in shared (commonMain) code to declare something that must be defined later in a platform-specific source.
Then, in the platform-specific code, you provide the real implementation using the actual keyword. This allows common code to reference platform-specific implementations cleanly.

\section{Android}
This sections concentrates on the benefits Kotlin has in the Android enviorment not only the language itself but also Kotlin based Tools for Android %cut? -> and gives examples based on the salesperson example from New Language Constructs along the way.

\subsection{Jetpack Compose}
  %TODO(
  %Kotlin based Ui Tool Kit -
  %JC automaticly updates Ui hierarchy-
  %functions with @Composable /composables-
  %)
Jetpack Compose is a Kotlin-based UI toolkit that simplifies Android UI development. Unlike XML, it can cut UI code by up to 50\%. While it may slightly increase APK size and build time, the gains in productivity and maintainability outweigh these downsides.
Compose improves readability and handles UI updates automatically based on state changes so there is no need to manually update views or manage the states.
It also combines UI and logic. Unlike XML, where logic must be handled separately, Compose keeps everything together.
All UI functions must use the @Composable annotation so the compiler knows to treat them as UI elements that react to state. Without it, using elements like Text() would cause a compiler error.

\subsection{Android KTX}
Android KTX is a collection of Kotlin-friendly libraries that sit on top of the existing Android APIs. It doesn’t replace the Android SDK, but simplifies and enhances it to work better with Kotlin by for example using Coroutines instead of Threads.



\section{Conclusion}
Kotlin is a modern programming language that offers a concise syntax, improved class structures, and innovative features such as null safety. Its seamless interoperability with Java makes it a great choice for projects integrating with existing codebases and libraries. Kotlin's support for multiplatform development, particularly in Android, establishes it as a powerful option for cross-platform development.

While this paper provides a solid foundation, it only scratches the surface of Kotlin's capabilities. Advanced features such as smart casts, delegation, and destructuring declarations further enhance Kotlin's appeal. By also embracing functional programming paradigms inspired by languages like Haskell, Kotlin enables developers to write cleaner and more maintainable code while still benefiting from its object-oriented capabilities.

These features, combined with its modern design and developer-friendly syntax, make Kotlin a powerful alternative to Java and a compelling choice for developers.

\newpage
\printbibliography
\end{document}